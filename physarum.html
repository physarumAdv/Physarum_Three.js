<!DOCTYPE HTML>
<html>
    <head>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0px;
            border: 0;
            overflow: hidden;
            display: block;
        }
        </style>
        <script type="text/javascript" src="stats.min.js"></script>
    </head>

    <body>
        <canvas id="my_canvas" width="1320" height="660">
        Oops, your browser doesn't support html5 canvas!
        </canvas>

        <script type="vertex">
            attribute vec4 aPosition;
            void main () {
                gl_Position = aPosition;
                gl_PointSize = 1.0;
        }
        </script>

        <script type="fragment">
            precision mediump float;
            uniform vec4 uFragColor;
            void main () {
                gl_FragColor = uFragColor;
            }
        </script>

        <script>
        var POINT_NUMBER = 1000;
        var SIZE_Y = 660;
        var SIZE_X = 1320;
        var SENSORS = true;
        var START_Y = 150;
        var START_X = 500;
        var POINT_NUMBER = 10;
        var ADD_LENGTH = 15;


        class Modeling {
            constructor(trsCount = 1) {
                this.trsCount = trsCount;
                this.arrOrganism = [];
                POINT_NUMBER = trsCount;
                for (var i = 0; i < trsCount; ++i) {
                    this.arrOrganism.push(new Particle(START_Y, START_X));
                }
            }
            
            drawOutput() {
                for (var i_part = 0; i_part < this.arrOrganism.size(); ++i_part) {
                    /*dx = math.fabs(elem.x - START_X)
                    dy = math.fabs(elem.y - START_Y)
                    if (Math.sqrt(dx * dx + dy * dy) <= 5) {
                        this.arrOrganism[i_part].food = 255;
                    }*/

                    // Draw particle
                    // pygame.draw.circle(screen, (0 + elem.food, int(55 + elem.food/1.275), int(255 - elem.food/5.1)), (int(elem.x), int(elem.y)), 0, 0)
                }
            }
            
            locationUpdate() {
                var del = []
                for (var update = 0; update < this.arrOrganism.length; ++update) {
                    var elem = this.arrOrganism[update]
                    if (elem.y > 1 && elem.x > 1 && elem.x < SIZE_X - 1 && elem.y < SIZE_Y - 1) {
                        elem.move();
                        // elem.share();
                        var ans = elem.sence();
                        elem.rotate(ans[0], ans[1], ans[2]);
                        TrailMap[Math.round(elem.y)][Math.round(elem.x)] += 255;
                        /*if (FoodMap[Math.round(elem.y), Math.round(elem.x)] <= 10) {
                            FoodMap[Math.round(elem.y), Math.round(elem.x)] = 0;
                        } else {
                            del.push(this.arrOrganism.length[update]);
                        }*/

                        /*if (elem.food >= 20) {
                            elem.food -= 20
                        } else {
                            elem.x = 0;
                            elem.y = 0;
                        }*/
                    }
                }
            }
        }
        
        class Particle {
            constructor(y, x, heading = Math.random() * 360) {
                this.SA = 45;
                this.RA = 20;
                this.SO = 5;
                this.SS = 1;
                this.depT = 5;
                this.pCD = 0;
                this.sMin = 0;
                this.food = 255;
                this.foodTrH = 20;
                this.x = x;
                this.y = y;
                this.heading = heading;
            }
            
            share() {
                // TODO
            }
            
            test(y, x) {
                if (y >= 0 && x >= 0 && x < SIZE_X && y < SIZE_Y) { // TODO add right end
                    if (FoodMap[y][x] > 20) {
                        var transaction = 20;
                    } else {
                        var transaction = FoodMap[y][x];
                    }
                    FoodMap[y][x] -= transaction;
                }
            }
            
            move() {
                if (FoodMap[Math.round(this.y)][Math.round(this.x)] > 20) {
                    var food_amount = 20;
                } else {
                    var food_amount = FoodMap[Math.round(this.y)][Math.round(this.x)];
                }

                var dx = Math.sin(this.heading * Math.PI / 180) * this.SS;
                var dy = Math.cos(this.heading * Math.PI / 180) * this.SS;
                this.x += dx;
                this.y += dy;
                
                if (this.food <= 255 - 20) {
                    // this.food += food_amount;  // Transaction
                }
                this.test(Math.round(this.y), Math.round(this.x));
                this.test(Math.round(this.y + 1), Math.round(this.x));
                this.test(Math.round(this.y - 1), Math.round(this.x));
                this.test(Math.round(this.y), Math.round(this.x + 1));
                this.test(Math.round(this.y), Math.round(this.x - 1));
            }
            
            rotate(a, b, c) {
                /*if (d > 0 || g > 0) {
                    if (d > g) {
                        // turn leftans[0] != 0
                        this.heading += 5
                    } else {
                        // turn right
                        this.heading -= 5
                    }
                }*/

                var rand = Math.round(Math.random() * 20);
                if (rand == 1) {
                    // turn randomly
                    var r = Math.round(Math.random());
                    if (r == 0) {
                        this.heading += this.RA;
                    } else {
                        this.heading -= this.RA;
                    }
                } else {
                    if (b >= a && b >= c) {
                    } else if (b < a && b < c) {
                        // turn randomly
                        var r = Math.round(Math.random());
                        if (r == 0) {
                            this.heading += this.RA;
                        } else {
                            this.heading -= this.RA;
                        }
                    } else if (a >= b && a >= c) {
                        // turn left
                        this.heading += this.RA
                    } else if (c >= b && c >= a) {
                        // turn right
                        this.heading -= this.RA
                    }
                }
            }
            
            sence() {
                /*LEFT*/
                var dx1 = Math.round(Math.sin((this.heading + this.SA) * Math.PI / 180) * this.SO)
                var dy1 = Math.round(Math.cos((this.heading + this.SA) * Math.PI / 180) * this.SO)
                
                /*SENTER*/
                var dx2 = Math.round(this.heading * Math.PI / 180 * this.SO);
                var dy2 = Math.round(this.heading * Math.PI / 180 * this.SO);
                
                /*RIGHT*/
                var dx3 = Math.round(Math.sin((this.heading - this.SA) * Math.PI / 180) * this.SO)
                var dy3 = Math.round(Math.cos((this.heading - this.SA) * Math.PI / 180) * this.SO)
                
                try {
                    var element0 = TrailMap[Math.round(this.y + dy1)][Math.round(this.x + dx1)];
                    var element1 = TrailMap[Math.round(this.y + dy2)][Math.round(this.x + dx2)];
                    var element2 = TrailMap[Math.round(this.y + dy3)][Math.round(this.x + dx3)];
                    return [element0, element1, element2];
                } catch {
                    return [0, 0, 0];
                }
            }
        }
        
        function resiseCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }

    
        var stats = initStats();
        var canvas = document.getElementById('my_canvas');
        var gl = canvas.getContext('webgl') ||
                canvas.getContext('experimental-webgl');
        if (!gl) throw new Error('browser may not support webgl');
        window.addEventListener('resize', resiseCanvas, false)

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        var vertShaderObj = gl.createShader(gl.VERTEX_SHADER);
        var vertexShaderSrc = document.querySelector('[type="vertex"]').textContent;
        var fragShaderObj = gl.createShader(gl.FRAGMENT_SHADER);
        var fragmentShaderSrc = document.querySelector('[type="fragment"]').textContent;

        /******/
        function compile (gl, type, shaderSrc) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, shaderSrc);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        };
        /******/

        var vertexShader = compile(gl, gl.VERTEX_SHADER, vertexShaderSrc);
        var fragmentShader = compile(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);

        function link (gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(program));
            }
            return program;
        };

        var program = link(gl, vertexShader, fragmentShader);
        gl.useProgram(program);

        var aPosition = gl.getAttribLocation(program, 'aPosition');
        var uFragColor = gl.getUniformLocation(program, 'uFragColor');
        var positionLocation = gl.getAttribLocation(program, "aPosition");

        var point_data = [0, 0];
        // var delta = [];
        point_data.length = POINT_NUMBER * 2;
        // delta.length = POINT_NUMBER * 2;

        for (var i = 0; i < POINT_NUMBER * 2; i+=2) {
            point_data[i] = 0;
            // delta[i] = Math.random() * 0.01;
            // delta[i+1] = Math.random() * 0.01;
            // point_data[i] = 0; Math.random() * 2 - 1;
            // point_data[i+1] = 0; Math.random() * 2 - 1;
        }

        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point_data), gl.STATIC_DRAW);

        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.uniform4f(uFragColor, 0.0, 0.0, 0.0, 1.0);

        
        var TrailMap = [];
        var FoodMap = [];
        for (var i = 0; i < SIZE_X; ++i) {
            TrailMap[i] = [];
            FoodMap[i] = [];
            for (var j = 0; j < SIZE_Y ; ++j) {
                TrailMap[i][j] = 0;
                FoodMap[i][j] = 0;
            }
        }



        model = new Modeling(POINT_NUMBER);

        let then = 0;
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = now - then;   // deltaTime is now number of seconds since last frame
            then = now;    // save the for the next frame
            stats.begin();
            // gl.uniform4f(uFragColor, Math.random(POINT_NUMBER), Math.random(), Math.random(), 1.0);
            
            model.locationUpdate();
            
            for (var y = 0; y < SIZE_Y; ++y) {
                for (var x = 0; x < SIZE_X; ++x) {
                    if (TrailMap[y][x] >= 20) {
                        TrailMap[y][x] -= 20;
                    } else {
                        TrailMap[y][x] = 0;
                    }
                }
            }
            
            
            for (var i = 0; i < POINT_NUMBER; ++i) {
                point_data[i * 2] = model.arrOrganism[i].x / (SIZE_X / 2) - 1;
                point_data[i * 2 + 1] = model.arrOrganism[i].y / (SIZE_Y / 2) - 1;
            }

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point_data), gl.STATIC_DRAW);
            gl.drawArrays(gl.POINTS, 0, POINT_NUMBER);
            
            for (var i = 0; i < ADD_LENGTH; ++i) {
                model.arrOrganism.push(new Particle(START_Y, START_X));
                POINT_NUMBER++;
            }
            stats.end();

            // now loop by calling requestAnimationFrame to call this function again 
            requestAnimationFrame(render)
        }
        render()



        function initStats() {
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.body.appendChild( stats.dom );
            return stats;
        }
        </script>
    </body>
</html>
