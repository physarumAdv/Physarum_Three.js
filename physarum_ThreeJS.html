<!DOCTYPE HTML>
<html>
    <head>
        <title>Three.js</title>


        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>

    <body>
        <script src="build/stats.min.js"></script>
        <script src="build/dat.gui.min.js"></script>


        <script type="module">
            import * as THREE from "./build/three.module.js";

            import { OrbitControls } from './build/OrbitControls.js';
            import { GLTFLoader } from './build/GLTFLoader.js';
            import { RGBELoader } from './build/RGBELoader.js';
            import { RoughnessMipmapper } from './build/RoughnessMipmapper.js';


            const FizzyText = function () {
                this.particles = '0';
                this.R = 255;
                this.G = 255;
                this.B = 0;
                this.point_width = 0.01;

                window.R = 255;
                window.G = 255;
                window.B = 0;

                this.draw_cube = true;
                this.reset_defaults = function () {};
            };

            window.onload = function() {
                window.text = new FizzyText();
                const gui = new dat.GUI();
                gui.add(text, 'particles').listen();
                var R = gui.add(text, 'R', 0, 255);
                var G = gui.add(text, 'G', 0, 255);
                var B = gui.add(text, 'B', 0, 255);

                var texture = gui.add(text, 'draw_cube');
                var size = gui.add(text, 'point_width', 0.001, 0.05);
                gui.add(text, 'reset_defaults');


                size.onChange(function(value){
                    this.point_width = window.text.point_width;
                });

                R.onChange(function(value){
                    window.R = Math.round(window.text.R);
                });

                G.onChange(function(value){
                    window.G = Math.round(window.text.G);
                });

                B.onChange(function(value){
                    window.B = Math.round(window.text.B);
                });


                texture.onChange(function(value){
                    while(scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }

                    IS_MATRIX = !value;
                    add_textures(IS_MATRIX);
                });
            };


            function httpGet(theUrl) {
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.open("GET", theUrl, false); // false for synchronous request
                xmlHttp.send(null);
                return JSON.parse(xmlHttp.responseText);
            }


            function renderPoints(frame, scene) {
                /*
                Given points coordinates (frame) scene, and RGB color, adds all particles to a scene
                */

                // clear scene from points
                while(scene.children.length > 4) {
                    var selectedObject = scene.getObjectByName("point");
                    scene.remove(selectedObject);
                }

                var color = new THREE.Color("rgb(" + window.R + "," + window.G + "," + window.B + ")");
                var geometry = new THREE.SphereGeometry(text.point_width, 10, 10);
                var material = new THREE.MeshBasicMaterial({color: color, wireframe: false});
                for (var i = 0; i < frame["x"].length; ++i) {
                    var point = new THREE.Mesh(geometry, material);
                    point.position.x = frame["x"][i];
                    point.position.y = frame["y"][i];
                    point.position.z = frame["z"][i];
                    point.name = "point";
                    scene.add(point);
                }
                return scene;
            }


            function add_textures(matrix_style) {
                // create the shape
                var geometry = new THREE.BoxGeometry(1, 1, 1);
                if (!matrix_style) {
                    // create a material, color or image texture
                    var material = new THREE.MeshFaceMaterial(cubeMaterials);
                    var cube = new THREE.Mesh(geometry, material);
                    scene.add(cube);
                }


                // light
                var ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
                scene.add(ambientLight);

                var light1 = new THREE.PointLight(0xFFFFFF, 0.5, 500);
                light1.position.x = 3;
                light1.position.y = 2;
                light1.position.z = 2;
                scene.add(light1);

                var geometry = new THREE.SphereGeometry(0.1, 5, 5);
                var material = new THREE.MeshBasicMaterial({color: 0x0000FF, wireframe: true});
                var point = new THREE.Mesh(geometry, material);
                point.position.x = 3;
                point.position.y = 2;
                point.position.z = 2;
                scene.add(point);
            }


            var IS_MATRIX = false;
            var path = 'https://3docean.img.customer.envatousercontent.com/files/236653866/Featured.jpg?auto=compress%2Cformat&fit=crop&crop=top&w=590&h=590&s=321582fa8635db81a9818e57a69fd28e';
            var cubeMaterials = [
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // RIGHT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // LEFT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // TOP SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // BOTTOM SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // FRONT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide})  // BACK SIDE
            ];

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            var stats = initStats();

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            var pmremGenerator = new THREE.PMREMGenerator( renderer );
            pmremGenerator.compileEquirectangularShader();

            window.addEventListener('resize', function() {
                var width = window.innerWidth;
                var height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;x
                camera.updateProjectionMatrix();
            });

            document.addEventListener('keydown', onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var keyCode = event.which;
                console.log(keyCode);
                if (keyCode === 87) {
                    cube.position.y += 1;
                } else if (keyCode === 83) {
                    cube.position.y -= 1;
                } else if (keyCode === 65) {
                    cube.position.x -= 1;
                } else if (keyCode === 68) {
                    cube.position.x += 1;
                } else if (keyCode === 32) {
                    cube.position.set(0, 0, 0);
                }
            }

            new RGBELoader()
                .setDataType( THREE.UnsignedByteType )
                .setPath( 'build/models/' )
                .load( 'royal_esplanade_1k.hdr', function ( texture ) {

                    var envMap = pmremGenerator.fromEquirectangular( texture ).texture;

                    scene.background = envMap;
                    scene.environment = envMap;

                    texture.dispose();
                    pmremGenerator.dispose();

                    render();

                    var roughnessMipmapper = new RoughnessMipmapper( renderer );

                    var loader = new GLTFLoader().setPath( 'build/models/' );
                    loader.load('cobra.gltf', function (gltf) {
                        gltf.scene.traverse(function(child) {
                            if (child.isMesh) {
                                roughnessMipmapper.generateMipmaps(child.material);
                            }
                        });

                        // add 3D model to set
                        // scene.add(gltf.scene);

                        roughnessMipmapper.dispose();
                        render();
                    });
                });


            var controls = new OrbitControls(camera, renderer.domElement);
            add_textures(IS_MATRIX);
            camera.position.z = 3;

            // game logic
            var update = function() {
                // cube.rotation.x += 0.01;
                // cube.rotation.y += 0.005;
            };

            // draw scene
            var render = function() {
                renderer.render(scene, camera);
            };

            // run game loop (update, render, repeat)
            var GameLoop = function() {
                requestAnimationFrame(GameLoop);
                stats.begin();

                var data = httpGet("http://localhost:8080/get_frame");
                text.particles = data["x"].length;
                renderPoints(data, scene, IS_MATRIX);

                update();
                render();
                stats.end();
            };

            GameLoop();
            function initStats() {
                var stats = new Stats();
                stats.setMode(0); // 0: fps, 1: ms

                // Align top-left
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                document.body.appendChild( stats.dom );
                return stats;
            }
        </script>
    </body>
</html>