<!DOCTYPE HTML>
<html>
    <head>
        <title>Physarum</title>

        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; }
        </style>
    </head>

    <body>
        <script src="build/stats.min.js"></script>
        <script src="build/dat.gui.min.js"></script>


        <script type="module">
            import * as THREE from "./build/three.module.js";

            import { OrbitControls } from './build/OrbitControls.js';
            import { GLTFLoader } from './build/GLTFLoader.js';
            import { RGBELoader } from './build/RGBELoader.js';
            import { RoughnessMipmapper } from './build/RoughnessMipmapper.js';


            const FizzyText = function () {
                this.particles = '0';
                this.color = [255, 255, 0]; // RGB array
                window.color = [255, 255, 0];
                this.point_width = 0.01;

                this.time = 0;

                /* this.Sensor_angle = 0;
                this.Step_size = 0;
                this.Agent_rotation = 0;
                this.Sensor_offset = 0; */

                this.draw_cube = true;
                this.play = true;
                this.turn_on = false;

                this.reset_defaults = function () {
                    /* Here is the update */
                    for (var i = 0; i < window.gui.__controllers.length; i++) {
                        window.gui.__controllers[i].setValue(gui.__controllers[i].initialValue);
                    }
                };

                this.restart = function () {
                    FrameId = 2;
                    window.text.play = true;
                };
            };


            window.onload = function() {
                window.text = new FizzyText();
                window.gui = new dat.GUI({
                    load: JSON,
                    preset: 'Flow'
                });
                window.gui.remember(window.text);
                window.gui.add(window.text, 'particles').listen();

                var cl = window.gui.addColor(window.text, 'color');

                var texture = window.gui.add(window.text, 'draw_cube');
                var size = window.gui.add(window.text, 'point_width', 0.001, 0.02);
                window.gui.add(window.text, 'reset_defaults');

                var playback = window.gui.addFolder('Playback');
                // var stime = playback.add(window.text, 'time', 0, 1);
                var pcontrol = playback.add(window.text, 'play').listen();
                playback.add(window.text, 'restart');
                var saves = playback.addFolder('Load save');
                playback.open();

                /* var model = window.gui.addFolder('Model Settings');
                var sa = model.add(window.text, 'Sensor_angle');
                var ss = model.add(window.text, 'Step_size');
                var ar = model.add(window.text, 'Agent_rotation');
                var so = model.add(window.text, 'Sensor_offset'); */

                size.onChange(function(value){
                    this.point_width = window.text.point_width;
                });

                stime.onChange(function(value){
                    this.time = window.text.time;
                });

                cl.onChange(function(value){
                    window.color[0] = Math.round(value[0]);
                    window.color[1] = Math.round(value[1]);
                    window.color[2] = Math.round(value[2]);
                });

                texture.onChange(function(value){
                    while(window.scene.children.length > 0) {
                        window.scene.remove(window.scene.children[0]);
                    }

                    IS_MATRIX = !value;
                    add_textures(IS_MATRIX);
                });
            };


            function httpGet(theUrl) {
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.open("GET", theUrl, false); // false for synchronous request
                xmlHttp.send(null);
                return JSON.parse(xmlHttp.responseText);
            }

            function fileGet(file_name) {
                var rawFile = new XMLHttpRequest();
                var allText = '';
                rawFile.open("GET", file_name, false);
                rawFile.onreadystatechange = function () {
                    if(rawFile.readyState === 4) {
                        if(rawFile.status === 200 || rawFile.status === 0) {
                            allText = rawFile.responseText;
                        }
                    }
                };
                rawFile.send(null);
                return JSON.parse(allText);
            }

            function renderPoints(frame) {
                /*
                Given points coordinates (frame) window.scene, and RGB color, adds all particles to a window.scene
                */

                // clear window.scene from points
                while(window.scene.children.length > 4) {
                    var selectedObject = window.scene.getObjectByName("point");
                    window.scene.remove(selectedObject);
                }

                var color = new THREE.Color("rgb(" + window.color[0] + "," + window.color[1] + "," + window.color[2] + ")");
                var geometry = new THREE.SphereGeometry(text.point_width, 10, 10);
                var material = new THREE.MeshBasicMaterial({color: color, wireframe: false});
                for (var i = 0; i < frame["x"].length; ++i) {
                    var point = new THREE.Mesh(geometry, material);
                    point.position.x = frame["x"][i];
                    point.position.y = frame["y"][i];
                    point.position.z = frame["z"][i];
                    point.name = "point";
                    window.scene.add(point);
                }
            }


            function add_textures(matrix_style) {
                // create the shape
                var geometry = new THREE.BoxGeometry(1, 1, 1);
                if (!matrix_style) {
                    // create a material, color or image texture
                    var material = new THREE.MeshFaceMaterial(cubeMaterials);
                    var cube = new THREE.Mesh(geometry, material);
                    window.scene.add(cube);
                }

                // light
                var ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
                window.scene.add(ambientLight);
            }


            var IS_MATRIX = false;
            var path = 'https://3docean.img.customer.envatousercontent.com/files/236653866/Featured.jpg?auto=compress%2Cformat&fit=crop&crop=top&w=590&h=590&s=321582fa8635db81a9818e57a69fd28e';
            var cubeMaterials = [
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // RIGHT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // LEFT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // TOP SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // BOTTOM SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // FRONT SIDE
                new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide})  // BACK SIDE
            ];

            function restart() {
                window.scene = new THREE.Scene();
                window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                window.stats = initStats();

                window.renderer = new THREE.WebGLRenderer();
                window.renderer.setSize(window.innerWidth, window.innerHeight);

                document.body.appendChild(window.renderer.domElement);
                var controls = new OrbitControls(window.camera, window.renderer.domElement);
                var pmremGenerator = new THREE.PMREMGenerator(window.renderer);

                pmremGenerator.compileEquirectangularShader();

                window.addEventListener('resize', function () {
                    var width = window.innerWidth;
                    var height = window.innerHeight;
                    window.renderer.setSize(width, height);
                    window.camera.aspect = width / height;
                    window.camera.updateProjectionMatrix();
                });
                document.addEventListener('keydown', onDocumentKeyDown, false);

                function onDocumentKeyDown(event) {
                    var keyCode = event.which;
                    console.log(keyCode);
                    if (keyCode === 87) {
                        cube.position.y += 1;
                    } else if (keyCode === 83) {
                        cube.position.y -= 1;
                    } else if (keyCode === 65) {
                        cube.position.x -= 1;
                    } else if (keyCode === 68) {
                        cube.position.x += 1;
                    } else if (keyCode === 32) {
                        cube.position.set(0, 0, 0);
                    }

                }

                // 3D models loader
                new RGBELoader()
                    .setDataType(THREE.UnsignedByteType)
                    .setPath('build/models/')
                    .load('royal_esplanade_1k.hdr', function (texture) {

                        var envMap = pmremGenerator.fromEquirectangular(texture).texture;

                        window.scene.background = envMap;
                        window.scene.environment = envMap;

                        texture.dispose();
                        pmremGenerator.dispose();

                        render();
                        var roughnessMipmapper = new RoughnessMipmapper(window.renderer);
                        var loader = new GLTFLoader().setPath('build/models/');

                        loader.load('cobra.gltf', function (gltf) {
                            gltf.scene.traverse(function (child) {
                                if (child.isMesh) {
                                    roughnessMipmapper.generateMipmaps(child.material);
                                }
                            });

                            // add 3D model to set
                            window.scene.add(gltf.window.scene);
                            roughnessMipmapper.dispose();
                            render();
                        });
                    });
                add_textures(IS_MATRIX);
                window.camera.position.z = -3;
                window.camera.rotation.y = 3.14;
            }
            restart();

            var FrameId = 1;
            var current_save = 'save';
            var all_saves = ['1', '2', '3'];

            // game logic
            var update = function() {
                // cube.rotation.x += 0.01;
                // cube.rotation.y += 0.005;
            };

            // draw scene
            var render = function() {
                window.renderer.render(window.scene, window.camera);    
            };

            // run game loop (update, render, repeat)
            var data = fileGet('build/saves/' + current_save + '.json');
            var GameLoop = function() {
                requestAnimationFrame(GameLoop);
                window.stats.begin();

                var trigger = {'status': true};
                // var trigger = httpGet("http://localhost:8080/get_status");
                // var data = httpGet("http://localhost:8080/get_frame");

                if (window.text.play && FrameId < data.length - 1 && FrameId !== 0) {
                    FrameId++;
                }

                if (trigger['status']) {
                    window.text.particles = data[FrameId]["x"].length;
                    renderPoints(data[FrameId], window.scene, IS_MATRIX);
                }

                update();
                render();
                window.stats.end();
            };


            GameLoop(window.scene);
            function initStats() {
                window.stats = new Stats();
                window.stats.setMode(0); // 0: fps, 1: ms

                // Align top-left
                window.stats.domElement.style.position = 'absolute';
                window.stats.domElement.style.left = '0px';
                window.stats.domElement.style.top = '0px';
                document.body.appendChild( stats.dom );
                return stats;
            }
        </script>
    </body>
</html>