<!DOCTYPE HTML>
<html>
    <body>
        <canvas id="my_canvas" width="600" height="400">
        Oops, your browser doesn't support html5 canvas!
        </canvas>

        <script type="vertex">
            attribute vec4 aPosition;
            void main () {
                gl_Position = aPosition;
                gl_PointSize = 5.0;
        }
        </script>

        <script type="fragment">
            precision mediump float;
            uniform vec4 uFragColor;
            void main () {
                gl_FragColor = uFragColor;
            }
        </script>


        <script>
            /*const http = require('http');

            const hostname = '127.0.0.1';
            const port = 1303;

            const server = http.createServer((req, res) => {
            res.statusCode = 200;
            res.setHeader('Content-Type', 'text/plain');
            res.end('Hello World');
            });

            server.listen(port, hostname, () => {
            console.log(`Server running at http://${hostname}:${port}/`);
            });*/

            var vertices = [
              // Передняя грань
              -1.0, -1.0,  1.0,
               1.0, -1.0,  1.0,
               1.0,  1.0,  1.0,
              -1.0,  1.0,  1.0,
              
              // Задняя грань
              -1.0, -1.0, -1.0,
              -1.0,  1.0, -1.0,
               1.0,  1.0, -1.0,
               1.0, -1.0, -1.0,
              
              // Верхняя грань
              -1.0,  1.0, -1.0,
              -1.0,  1.0,  1.0,
               1.0,  1.0,  1.0,
               1.0,  1.0, -1.0,
              
              // Нижняя грань
              -1.0, -1.0, -1.0,
               1.0, -1.0, -1.0,
               1.0, -1.0,  1.0,
              -1.0, -1.0,  1.0,
              
              // Правая грань
               1.0, -1.0, -1.0,
               1.0,  1.0, -1.0,
               1.0,  1.0,  1.0,
               1.0, -1.0,  1.0,
              
              // Левая грань
              -1.0, -1.0, -1.0,
              -1.0, -1.0,  1.0,
              -1.0,  1.0,  1.0,
              -1.0,  1.0, -1.0
            ];

            var colors = [
              [1.0,  1.0,  1.0,  1.0],    // Front face: white
              [1.0,  0.0,  0.0,  1.0],    // Back face: red
              [0.0,  1.0,  0.0,  1.0],    // Top face: green
              [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
              [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
              [1.0,  0.0,  1.0,  1.0]     // Left face: purple
            ];

            var canvas = document.getElementById('my_canvas');
            var gl = canvas.getContext('webgl') ||
                    canvas.getContext('experimental-webgl');
            if (!gl) throw new Error('browser may not support webgl :(');
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            var vertShaderObj = gl.createShader(gl.VERTEX_SHADER);
            var vertexShaderSrc = document.querySelector('[type="vertex"]').textContent;
            var fragShaderObj = gl.createShader(gl.FRAGMENT_SHADER);
            var fragmentShaderSrc = document.querySelector('[type="fragment"]').textContent;

            /******/
            function compile (gl, type, shaderSrc) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, shaderSrc);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error(gl.getShaderInfoLog(shader));
                }

                return shader;
            };
            /******/

            var vertexShader = compile(gl, gl.VERTEX_SHADER, vertexShaderSrc);
            var fragmentShader = compile(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);

            function link (gl, vertexShader, fragmentShader) {
                var program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(program));
                }

                return program;
            };

            var program = link(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            var aPosition = gl.getAttribLocation(program, 'aPosition');
            var uFragColor = gl.getUniformLocation(program, 'uFragColor');
            var positionLocation = gl.getAttribLocation(program, "aPosition");
            // var positionLocation = gl.getAttribLocation(program, "");
            // var positionLocation = gl.getAttribLocation(program, "aClal");
            
            // perspectiveMatrix = makePerspective(45, 640.0/480.0, 0.1, 100.0);

            function setMatrixUniforms() {
                var pUniform = gl.getUniformLocation(program, "uPMatrix");
                gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));

                var mvUniform = gl.getUniformLocation(program, "uMVMatrix");
                gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));
            }

            var point_data = [
                -0.8, -0.0,
                -0.4, 0.8,
                -1.0, 1.0,
                -1.0, -1.0,
                1.0, -1.0,
                1.0, 0.0];


            var generatedColors = [];

            for (j=0; j<6; j++) {
                var c = colors[j];
              
                for (var i=0; i<4; i++) {
                    generatedColors = generatedColors.concat(c);
                }
            }

            cubeVerticesColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW);
            
            cubeVerticesIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);

            // Этот массив определяет каждую грань как два треугольника,
            // используя индексы в массиве вершин, чтобы определить позицию
            // каждого треугольника.

            var cubeVertexIndices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23    // left
            ];

            // Теперь отправим массив элементов в GL

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);


            // var buffer = gl.createBuffer();
            // gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point_data), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            //gl.vertexAttrib2f(aPosition, 0.0, 1.0);
            gl.uniform4f(uFragColor, 1.0, 0.0, 0.0, 1.0);

            // takes a mode, first, count
            // gl.drawArrays(gl.POINTS, 0, 1);
            // gl.clearColor(0.0, 0.0, 0.0, 1.0);
            // gl.clear(gl.COLOR_BUFFER_BIT);

            var delta = [];
            delta.length = point_data.length;
            for (var i = 0; i < delta.length; i+=2) {
                delta[i] = Math.random() * 0.01;
                delta[i+1] = Math.random() * 0.01;
            }
            
            let then = 0;
            function render(now) {
                now *= 0.001;  // convert to seconds
                const deltaTime = now - then;   // deltaTime is now number of seconds since last frame
                then = now;    // save the for the next frame

                gl.uniform4f(uFragColor, Math.random(), Math.random(), Math.random(), 1.0);
                for (var i = 0; i < point_data.length; i+=2) {
                    point_data[i] += delta[i];
                    point_data[i+1] += delta[i+1];
                    if (point_data[i] < -1 || point_data[i] > 1) {
                        delta[i] = delta[i] * -1;
                    }
                    if (point_data[i+1] < -1 || point_data[i+1] > 1) {
                        delta[i+1] = delta[i+1] * -1;
                    }
                }
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(point_data), gl.STATIC_DRAW);
                gl.drawArrays(gl.POINTS, 0, 6);

                // gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
                // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
                // setMatrixUniforms();
                // gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

                // mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation * .7, [0, 1, 0]);
                // now loop by calling requestAnimationFrame to call this function again
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
            
        </script>
    </body>
</html>
